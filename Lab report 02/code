# Lab 02: Divide and Conquer â€“ Merge Sort and Binary Search (Recursive)

## Learning Objectives

- Understand Divide and Conquer paradigm.
- Implement Merge Sort (recursive and iterative).
- Implement recursive Binary Search.
- Analyze time and space complexity.

---

## Theory Recap

**Divide and Conquer** splits problems into smaller subproblems solved recursively and combined.

---

## Experiment 1: Merge Sort (Recursive)

**Time Complexity:** O(n log n)  
**Space Complexity:** O(n)

### Source Code (C++)

```cpp
// Merge Sort
#include<iostream>
using namespace std;
#define MAX 20

void print(int ar[], int siz) {
    for(int i = 0; i < siz; i++)
        cout << ar[i] << ' ';
    cout << endl;
}

void subArray(int ar[], int lb, int lr, int rb, int rr) {
    int na = lb, nb = rb, nc = lb, k, c[MAX];
    while((na <= lr) && (nb <= rr)) {
        if(ar[na] < ar[nb])
            c[nc++] = ar[na++];
        else
            c[nc++] = ar[nb++];
    }

    if(na > lr) {
        while(nb <= rr)
            c[nc++] = ar[nb++];
    } else {
        while(na <= lr)
            c[nc++] = ar[na++];
    }

    for(k = lb; k <= rr; k++)
        ar[k] = c[k];
}

void merge_sort(int ar[], int st, int ed) {
    int mid;
    if(st < ed) {
        mid = (st + ed) / 2;
        merge_sort(ar, st, mid);
        merge_sort(ar, mid + 1, ed);
        subArray(ar, st, mid, mid + 1, ed);
    }
}

int main() {
    int Array[7] = {56, 0, 5, 0, 3, 9, 1};
    print(Array, 7);
    merge_sort(Array, 0, 7 - 1);
    print(Array, 7);
}
```
### Sample Output

![Linear Search Output](https://github.com/SHUVO-05/CSE-2202-Algorithm-Design-and-Analysis-Sessional/blob/main/Lab%20report%2002/Merge%20Sort.png)
---

## Experiment 2: Recursive Binary Search

**Time Complexity:** O(log n)  
**Space Complexity:** O(log n) (due to recursion stack)

### Source Code (C++)

```cpp
// Recursive Binary Search
#include<iostream>
using namespace std;

void print(int ar[], int siz) {
    for(int i = 0; i < siz; i++)
        cout << ar[i] << ' ';
    cout << endl;
}

// Only use for sorted array
void Binary_search(int ar[], int len, int item) {
    int lb = 0, ub = len - 1, mid = (lb + ub) / 2;
    while(lb <= ub && ar[mid] != item) {
        if(item < ar[mid])
            ub = mid - 1;
        else
            lb = mid + 1;
        mid = (lb + ub) / 2;
    }
    if(ar[mid] == item)
        cout << "Item " << item << " is found at position " << mid + 1 << endl;
    else
        cout << "Item not found" << endl;
}

// Only use for sorted array
int Binary_search_recursive(int ar[], int lb, int ub, int item) {
    if(lb > ub) return -1;
    int mid = (lb + ub) / 2;

    if(item == ar[mid])
        return mid;
    else if(item < ar[mid])
        return Binary_search_recursive(ar, lb, mid - 1, item);
    else
        return Binary_search_recursive(ar, mid + 1, ub, item);
}

int main() {
    int item;
    int Array[8] = {5, 65, 150, 235, 321, 573, 789, 1278};
    print(Array, 8);
    cout << "Enter your item you want to search: ";
    cin >> item;
    Binary_search(Array, 8, item);
}
```
### Sample Output

![Linear Search Output](https://github.com/SHUVO-05/CSE-2202-Algorithm-Design-and-Analysis-Sessional/blob/main/Lab%20report%2002/Binary%20Search%20recursive.png)
---

## Summary

- **Merge Sort** follows the divide-and-conquer strategy and ensures consistent performance with O(n log n) time.
- **Recursive Binary Search** provides efficient search in sorted arrays but relies on a recursive stack, hence O(log n) space.
- Mastering these recursive patterns is essential for solving complex problems efficiently.

